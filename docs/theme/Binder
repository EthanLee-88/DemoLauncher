
 /***********************  Binder进程间通信  **************************/

  我们都知道Android一个进程它是有独立的内存的，而且进程间的内存是无法共享的。
  在诸多的进程方案当中，Android选择了Binder。
  操作系统在逻辑上将虚拟空间分为用户空间和内核空间。Binder机制是通过使用Linux
  内核空间来实现进程间通信的。在这种机制下会运行于内核的Binder驱动会创建两个
  内核缓存区，其中一个是内核中数据接收缓存区，并在两者间建立内存映射。且在
  数据接收缓存区与数据接收用户空间间建立内存映射，以此来减少数据拷贝，提升效率。

  *第二部分讲客户端和服务端建立Binder连接的大概流程。
  我们知道，服务端Service要对外提供服务就需要在ServiceManager上进行注册，具体的
  做法是将在Service内创建的Binder实体连同名字发送给Binder驱动，驱动给这个Binder
  实体在内核中创建实体节点以及对实体的引用，然后Binder驱动将Binder实体的名字及引
  用传给ServiceManager填入查找表，自此完成Service的注册。

  值得一提的是，Service在ServiceManager注册的过程也是一个进程间通信，但此通信与
  我们开发者平时自定义的Binder通信不一样。主要是因为ServiceManager作为服务端，
  已经默认创建了自己的Binder，而且没有名字也不需要注册，也就是0号Binder实体。
  因为已经默认创建而且已经公开，所以外界所有客户端都可以使用默认0号引用通过Binder
  驱动与ServiceManager进行通信。

  Service在ServiceManager注册完成后，外界的客户端就可以根据service名称，在Binder
  驱动的帮助下在ServiceManager里查找相应的Binder了，查找到之后Binder驱动就会将
  ServiceManager内服务端的Binder引用返回给客户端，以完成客户端和服务端之间的绑定。

  *第三部分讲开发者自定义Binder进程间通信的一些事项
   我们知道，一般在进行这个自定义Binder进程间通信的时候，我们都会先去声明一个AIDL
   接口，AIDL接口的作用就是让平台帮我们生成用于进程间通信的工具类。当然，我们也完全
   可以不使用AIDL接口，自己去写这个工具类。Android官方提供这个AIDL的方式就是希望能
   让开发者减少模板代码的书写。
   这个AIDL接口生成的工具其实是一个java接口，这个接口声明了服务端能对外提供的服务。
   当然，里面有一个很重要的叫做Stub的静态内部内。该类继承了Binder，用于服务端创建
   Binder实例。
   除此之外，Stub类里还有一个更重要的静态内部类Proxy，这个类实现服务端对外声明的
   方法。我们知道，由于进程隔离的原因，客户端是无法直接调用远程服务端的数据查询的
   方法的，这样就需要使用此代理来模拟调用远程方法。代理类里最重要的操作就是使用远程
   服务端Binder引用所调用的一个叫transact的方法，这个操作是客户端进行进程间通信的
   核心，该方法的底层实现是一个Native方法，该方法将我们在客户端调用的与服务端相对应
   的方法编号以及经过序列化处理的参数打包传给底层Binder驱动，然后底层Binder驱动进行
   相关匹配后将数据发给相关服务端，服务端会触发onTransact方法，根据方法编号判断出客
   户端的请求意图，然后在取出客户端传过来的参数进行相关的查询或者插入操作。得到结果
   后返回给Binder驱动，Binder驱动再转发给客户端，自此解除客户端的线程阻塞。

   xxx.aidl 中不能存在同方法名不同参数的方法。
   xxx.aidl 中实体类必须要有指定的tag。
