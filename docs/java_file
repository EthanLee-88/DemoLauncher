/************************************ 面试题 ***********************************/
/***** java部分  ******/
1、java中==和equals和hashCode的区别
   ==只可以用于比较类型上有继承关系的两个对象。
   ==比较两个引用变量要求两变量指向同一个对象才返回true。
   java基类Object的equals（）方法的判断逻辑同==，所以不同的java类重写了不同逻辑的
   equals方法。

1.0、hashCode()
    hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。
    不同的对象可能会生成相同的hashcode值,如果两个对象的hashcode值不等，
    则必定是两个不同的对象。
    如果要判断两个对象是否真正相等，必须通过equals方法。
    (用hashCode只能判断两个对象不相等)
    当两个对象hashCode相等时，需要用equals（）方法进一步判断对象是否相等。

2、int、char、long各占多少字节数
   int及float占4个字节（32位），char型占2个字节（16位），每进一个刻度翻一倍。
   byte 、short | char 、 int | float 、 long | double。

 3、int与integer的区别
    int是基本数据类型，integer是引用数据类型，或者说integer是一个java类，作为
    java类，integer提供了众多对数据进行操作的方法，比如说将字符串转换成整型的
    parseInt()方法。

 4、谈谈对java多态的理解
    相同类型的变量在调用同一方法时表现出不同的行为特征即为多态。
    引用变量在编译时的类型由声明它的类型所决定，运行时的类型由赋给它的实例所决定。java
    允许把一个子类的对象直接赋值给一个父类声明的变量，运行时调用子类的方法是，方法总表
    现出子类的行为特征。

 5、String、StringBuffer、StringBuilder区别
    String这个字符串类型是不可变的，StringBuffer和StringBuilder可变，StringBuffer
    线程安全，StringBuilder线程不安全，StringBuilder比StringBuffer性能高。

 6、什么是内部类？内部类的作用
    定义在其它类内部的类称为内部类。内部类提供了更好的封装，可以把内部类隐藏在外部类之内。

 7、抽象类和接口区别
    接口是一种规范，是多个模块间的耦合标准，是一种通信规范。一般用于规范模块间的通信。而
    抽象类是一种模板式设计，作为多个子类的抽象父类。另外，抽象类遵循java类单继承的特性，
    而接口可以实现多继承，以弥补java单继承的不足。可以说接口也是一种抽象类，相对于抽象类
    有更多的限制，比如接口里不包含构造器，抽象类的构造器用来给子类调用。

 8、抽象类的意义
    模板、规范，对多个具有相同特征的类当中抽象出来，作为一种模板，避免了子类设计的随意性。

 9、接口的意义
    多模块间采用面向接口的耦合，以降低模块间的耦合。

 10、抽象类是否可以没有方法和属性？
    包含抽象方法的类只能被定义成抽象类，抽象类可以没有抽象方法。

 11、抽象类与接口的应用场景
     工厂模式和MVP

 12、泛型中extends和super的区别
     <? extends T> 设置了通配符的上限 ，表示此类型必须是T类型的子类或T本身。
     <? super T> 设置了通配符的 ， 表示此类型必须是T的父类或T本身

     没有泛型类，为一个集合指定类型的时候只是指定了集合元素的类型，集合的类型没变。
     泛型方法，可用泛型方法替换泛型通配符<>，在方法返回值前声明确定类型的限定方式。

 13、父类的静态方法能否被子类重写
     可以，但子类重写的方法也必须是静态方法。方法不能同时拥有抽象和静态两种属性。

 14、进程和线程的区别
     线程时CPU调度的最小单元，一个进程里有一个或多个线程，多线程下执行并发任务。

 15、final，finally，finalize的区别
     final关键字修饰的类、方法、变量不可变。final类不能被继承， final方法不能被重写
     fina变量不能被重新赋值。

     finally时异常处理机制提供的用于资源回收的代码块结构。finally和catch块可以二选一
     同时存在时finally位于catch之后。

     finalize()是一个java.lang.Object里的方法，该方法在所在对象呗gc回收时被调用。

 16、Serializable 和 Parcelable 的区别
     类实现序列化接口。Serializable是java提供的序列化接口，采用ObjectInputStream
     和ObjectOutputStream即可轻松实现序列化和反序列化的过程。另外，通过应通过手动
     固定序列化ID值来确保系统不自动使用hash值而导致的反序列化失败。

     Parcelable是Android提供的实现序列化方式的接口。
     一个类实现 Parcelable接口，就需要重写两个方法：writeToParcel(Parcel out, int i)
     (序列化) 、describeContents（）。此外还需一个带 Parcel形参的构造器， 需要一个
     CREATOR 来实现反序列化的操作。

     区别：Serializable包含大量I/O操作，开销大，主要用于存储设备或网络传输的序列化
           Parcelable性能高，主要用于内存的序列化，使用相对麻烦一点。

 17、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？
     静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制即可
     以调用。子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在"隐藏"的这种
     情况。静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写。

 18、CopyOnWriteArrayList
     CopyOnWriteArrayList读的时候不加锁，但写的时候加锁。当读的时候有多个线程添加数据，
     那么会读到旧数据，因为写的时候不会锁住旧数据。写的时候有一个备份的操作，所以不会对
     旧数据造成影响，写完之后再对旧数据进行更新。适合读多写少的操作。

 19、静态内部类的设计意图
     静态内部类不依赖于外部实例，所以静态内部类所有静态的和非静态的成员都无法访问外部类
     的实例成员。
     与成员内部类相比，静态内部类既可以访问外部类的静态成员，创建静态内部类实例时又不需
     要创建外部类实例，因为静态内部类是类相关的。

 20、成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用
     局部内部类：方法里定义的类，少用。
     匿名内部类：只使用一次的，没有引用的。比如给控件设置点击事件所要传的接口实现类。
                 其实匿名内部类通常也是局部内部类的java的一种省略的写法，匿名内部类
                 通常是一个接口的实现类，只是将实现接口的Class类声明省略了，所以就
                 看不到接口实现类的类名，于是局部内部类的实现就省略成了匿名内部类；
     静态内部类：静态内部类的单例模式，AIDL进程间通信的Binder。

       class Inner implements View.OnClickListener{ //局部内部类
                 @Override
                 public void onClick(View view) {}
             }
             View.OnClickListener inner = new Inner();
             messengerButton.setOnClickListener(inner);

             messengerButton.setOnClickListener(new View.OnClickListener() { //匿名内部类
                 @Override
                 public void onClick(View view) {
                 }
             });

 21、谈谈对kotlin的理解

 22、闭包和局部内部类的区别
     闭包是指可以包含自由变量的代码块(或函数或可调用的对象),该变量通常是局部变量。
     闭包是通过“接口+内部类”实现，JAVA的内部类也可以有匿名内部类
     让某些对象的生命周期加长。
     让自由变量的生命周期变长，延长至回调函数执行完毕。
     闭包共享。
     final关键字。
     总结：无论是何种内部类，要形成闭包都有一个特点，就是引用了其所在环境的局部变量
           在参数传递过程中通常使用final关键字将局部变量生命周期延长；

 23、string 转换成 integer的方式及原理
     通过遍历字符串里面的字符ascii码的相关数值范围进行比较，然后通过Character.digit()；
     方法将数字字符转换成数值。radix参数是进制，比如十进制。一个数字字符的ascii码减去
     "0"的结果就是该数字大小。

     /********************************** java进阶  **************************************/

 1、哪些情况下的对象会被垃圾回收机制处理掉
    软引用：内存不足时会被回收
    弱引用：对象随时可能被回收

 2、讲一下常见编码方式？
    UTF-8、UTF-16、GBK

 3、utf-8编码中的中文占几个字节；int型几个字节？
    Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。
    UTF-8是在互联网上使用最广的一种 Unicode 的编码方式。
    UTF-8是一种长度可变的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
    UTF-8用3个字节表示汉字。

 4、静态代理和动态代理的区别，什么场景使用？
    静态代理在编译时已经存在代理类的对象，而动态代理则在运行时通过反射来动态地生成代理类的对象。
    动态代理可以代理不同的抽象主题类，此方式与类无关，实现代理者与被代理者解耦。静态代理则只可
    以代理固定的抽象主题，代理者与被代理者耦合。

 5、Java的异常体系

 6、谈谈你对解析与分派的认识

 7、修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？
    调用了Key值的equals方法。 方法被重载，也许无法覆盖Object类的equals方法。

    Java8改进的HashMap是线程不安全的，可以用Collections将之变成安全的。HashMap以键值对的形式
    存储对象。HashMap可以存在null的Key值或Value值，不能有重复的Key值，但可以有相同的Value值。
    和HashSet检查Value值方法一样，HashMap通过hashCode和equals方法判断Key值是否已经存在。而
    containValue方法判断Value值时，直接用equals判断。HashMap添加自定义的对象重写hashCode方
    法和equals方法的原则与HashSet相同。

 8、Java中实现多态的机制是什么？
    Java实现多态有三个必要条件：继承、重写、向上转型。

 9、如何将一个Java对象序列化到文件里？
    使对象的类型实现serializable接口，然后分别使用ObjectInputStream，ObjectOutputStream的
    readObject 及 writeObject 输入输出即可。

 10、说说你对Java反射的理解
     首先，反射技术可以动态加载一个类，并获取这个类的包括类名、字段、方法、构造器等所有信息，
     同时，也可以通过反射来创建类的对象。总之，说到反射的功能的话，动态 是关键字，在运行时
     动态的类加载、动态地获取类的所有信息、动态地创建类的对象等，而不是在编译时明确类的信息。
     反射在日常的开发当中还是很常见的，正因为可以动态地创建，所以就使得相关的逻辑可以和外界
     实现良好的解耦。工厂模式和动态代理模式都用到了反射。

 11、说说你对Java注解的理解
     注解就是另类的注释，通过注解可以为程序提供一些信息或元数据，这些信息或元数据可以在编译
     或运行时被读取，从而提供额外的处理信息。
     运行时注解需要通过反射获取注解的相关信息。java注解可以再编译、类加载、运行时被读取。

 12、说说你对依赖注入的理解
     依赖注入就是将两个有依赖关系的对象解耦。通过第三方机构将完整的被依赖对象注入到需要依赖
     的对象，避免在需要依赖的对象里直接创建被依赖对象，从而实现解耦。典型的做法是通过方法、
     构造器或者接口实施对象注入。依赖注入框架有比如ButterKnife，严格来说ButterKnife不算依赖
     注入框架，因为它更注重于View的注入。

 13、说一下泛型原理，并举例说明
     泛型就是参数化类型，从java5开始，不允许将对象丢进类型未知的集合里。所以在使用集合时需要
     指定集合元素类型。比如使用一个数组列表ArrayList时在声明时指定类型。

     所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这些类型形参可以分别在类、接口、方
     法里当成普通类型使用。

     通配符的作用是支持灵活的子类化，可以实现不同的调入点传入不同的实际类型。

     泛型方法的定义：在方法返回值前在<>里声明一个或多个类型形参。
     泛型方法的使用场景：在定义类、接口时没有使用类型形参，且方法需要用到类型形参。
     大多数情况下都可以用泛型方法来代替类型通配符，在三种情况下必须使用泛型方法来代替泛型通配符：
     *一是方法的多个泛型形参之间存在依赖关系，则必须把依赖关系的一端类型确定下来，即在<类型形参>列表
       里声明该类型，然后与其他确定继承关系。
     *二是在方法体里需要用到该类型，类型通配符？无法作为确定类型在方法里使用。
     *三是方法返回值类型与形参的类型存在依赖关系（或者就是形参类型），则需要将类型的<类型形参>声明
      放入尖括号的列表中，将类型确定下来。
      总之，尖括号里的类型参数之所以被声明，是因为要用到，需要使用才回去声明。一旦声明下来就可以
      当成普通类型使用。以上三种情况就是使用场景。

      简单地将泛型就是，外界向一个对象或者一个方法传递进来一个参数的时候，该对象或方法又不提前知道
      外界传的这个参数是什么类型的，而对象里或方法里又需要用到这个参数。那这个时候就需要在类或者方法
      里将该未知类型确定下来，在尖括号里把它声明成类型形参。这样在类或者方法里就可以使用了。当外界
      将一个具体类型的实参传进来之后，我们声明的该类型形参就变成了类型实参。

 14、Java中String的了解
     String对象的字符串对象不可变，一旦对象创建就不可变，直至对象被销毁。

 15、String为什么要设计成不可变的？
     为了安全。HashMap和HashSet要求键值不可变。

 16、Object类的equal和hashCode方法重写，为什么？
